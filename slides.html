<!DOCTYPE html>
<html>
  <head>
    <title>mysh slides</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/reveal.js/2.6.2/css/reveal.min.css">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/reveal.js/2.6.2/css/theme/default.css">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/monokai_sublime.min.css">

    <script src="//cdnjs.cloudflare.com/ajax/libs/reveal.js/2.6.2/lib/js/head.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/reveal.js/2.6.2/lib/js/html5shiv.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/reveal.js/2.6.2/lib/js/classList.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/highlight.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/languages/cpp.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/reveal.js/2.6.2/js/reveal.min.js"></script>
  </head>
  <body>
  <div class="reveal">
    <div class="slides">
      <section>
<h1>mysh</h1>
<h2>design implementation</h2>
<h4>Created by Andrew, Jacob, Julian, Landan, and Mike</h4>

      </section>
      <section>

<h3>Strategy for the Shell's Design</h3>

<ul>
  <li>Larger group let us focus on code structure and maintainability when creating our implementation of mysh</li>
  <li>We took an object-oriented approach and wrote our implementation in C++11</li>
</ul>

      </section>
      <section>
        <section>

<h3>Core Concepts</h3>

<ul>
  <li>Dependency Injection</li>
  <li>Inversion of Control</li>
  <li>Separation of Concerns</li>
</ul>

        </section>
        <section>

<h3>Dependency Injection</h3>

<ul>
  <li>To put it simply, dependency injection (DI) let us write our application modularly</li>
  <li>We developed a single, central component that knows about all other components</li>
  <li>If a component depends on other components, it can resolve these dependencies via the central component</li>
</ul>

        </section>
        <section>

<h3>Inversion of Control</h3>

<ul>
  <li>The concept powering that "central component"</li>
  <li>We call this component our IoC container, and we register all available internal commands with it</li>
  <li>Our Parsers and Shell classes resolve commands from this IoC container</li>
  <li>Registering commands is really simple:</li>
</ul>

<pre><code data-tim class="cpp">
class MyCommand : Command { /* Class Logic */ }
Commander commands();

int main(){
    // Register a command with the IoC
    commands.enable("mycommand", /* MyCommand constructor */);
    
    // Resolving a command from the IoC
    Command myCmd = commands.resolve("mycommand", /* constructor arguments */);

    cout >> myCmd.execute();
}
</code></pre>

        </section>
      </section>
      <section>
        <section>

<h3>Separation of Concerns</h3>

<ul>
  <li>We knew that a solid, object-oriented approach to the software requirements would let us solve "hard" problems easily
  <li>Five main classes compose the core of our implementation of mysh:
    <ol>
      <li>Shell</li>
      <li>Parser</li>
      <li>Command</li>
      <li>IoC Container</li>
      <li>Shell Error</li>
    </ol>
  </li>
</ul>

        </section>
        <section>

<h3>Shell Class</h3>

<ul>
  <li>Provides a very simple Read-Evaluate-Print Loop (REPL)</li>
  <li>Also responsible for looping through an input file and parsing it (batch file mode)</li>
  <li>When a user types in a command, the Shell creates a Parser to execute the typed command</li>
  <li>Semicolon delimitted commands are handled by the shell</li>
  <li>Primary source of error handling</li>
</ul>

        </section>
        <section>

<h3>Command Class</h3>

<ul>
  <li>Interface class that provides a standard API for all commands to implement</li>
  <li>Requires an execute method that returns the output as a string</li>
  <li>Returning a string simplifies our output redirection process</li>
</ul>
<pre><code data-tim class="cpp">
class Command{
public:
  vector&lt;string&#62; arguments;
  bool shouldExit;
  
  Command( vector&lt;string&#62; args ){
    this->arguments = args;
    this->shouldExit = false;
  }

  virtual string execute() = 0;
}
</code></pre>
        </section>
        <section>

<h3>IoC Container Class</h3>

<ul>
  <li>Very simple IoC container implementation</li>
  <li>Each command is enabled by storing the command name and the constructor of the class in a map</li>
  <li>Command resolution happens like this:
    <ol>
      <li>Does the map of internal commands contain the command name? Return the correct command</li>
      <li>Does the command name end in '.cpp' or '.c' ? Return a QuickCompile command</li>
      <li>If the command name does not satisfy any of the above conditions, return an External command</li>
    </ol>
  </li>
</ul>

        </section>
        <section>

<h3>Parser Class</h3>

<ul>
  <li>This is where the bulk of our implementation's complexity exists</li>
  <li>Takes a command string like <code>ls -l >> files.txt</code> and parses it into blocks</li>
  <li>Simpler approach to parsing instead of regular expressions</li>
  <li>Each "block" in the command string is added to a queue like this:
    <ol>
      <li><code>ls</code></li>
      <li><code>-l</code></li>
      <li><code>&gt;&gt;</code></li>
      <li><code>files.txt</code></li>
    </ol>
  </li>
</ul>
        </section>
        <section>
<ul>
  <li>Top of the queue is expected to be the name of the command</li>
  <li>Every other object in the queue is treated like an argument</li>
  <li>Output redirectors are detected and handled accordingly</li>
  <li>After parsing is completed, parser resolves the command from the IoC container</li>
</ul>

        </section>
        <section>

<h3>Shell Error Class</h3>
<ul>
  <li>We make heavy use of C++'s try, catch, and throw syntax to make error handling clear and easy to follow</li>
  <li>Normally, there would be a class for each error type the command might encounter</li>
  <li>Software requirements for mysh only required one error</li>
</ul>

        </section>
      </section>
      <section>

<h3>Reflections on Design</h3>
<ul>
  <li>Worked well for us when developing mysh</li>
  <li>Makes the codebase easy to ready and makes adding new functionality to the shell straightforward</li>
  <li>Improvements could be made to operator handling</li>
</ul>

      </section>
      <section>
        <section>

<h3>Regarding our Development Process</h3>
<ul>
  <li>Used git as our version control system instead of Google Drive</li>
  <li>Documentation created colloboratively using documentation comment blocks in our source code</li>
</ul>

        </section>
        <section>

<h3>Git and Github</h3>
<ul>
  <li>Git let us easily work on the same body of code without worrying about overwrites or merging</li>
  <li>Hosted our git repository on Github. Full source code and slides for our shell can be found at https://github.com/MikeRyanDesigns/mysh</li>
  <li>Github let us view changes in the source code as well as create issues</li>
</ul>

        </section>
        <section>

<h3>Documentation Comment Blocks</h3>
<ul>
  <li>In our source code, we annotate our classes with documentation blocks</li>
  <li>Using a third party parser (in this case Yuidoc, developed at Yahoo) documentation is generated from the source code</li>
  <li>Documentation generation process automated via our makefile</li>
</ul>

<pre><code data-tim class="cpp">
/**
* Demo class description
*
*
* @class Demo
*/
class Demo{
  /**
  * Property description
  *
  * @property {vector&lt;string&#62;} arguments
  */
  vector&lt;string&#62; arguments;

  /**
  * Method description
  *
  * @method simpleMethod
  * @param {vector&lt;string&#62;} arguments Description of paramter
  * @return {bool} Description of the return value
  */
  bool simpleMethod( vector&lt;string&#62; arguments ){ }
}
</code></pre>

        </section>
      </section>
      <section>

<h3>Questions?</h3>

      </section>
    </div>
  </div>

  <script type="text/javascript">
Reveal.initialize({// Transition style
    transition: 'linear'
});
hljs.initHighlightingOnLoad();
  </script>
  </body>
</html>
