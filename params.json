{"name":"mysh - Simple Unix Shell","tagline":"Project for Unix Programming","body":"mysh\r\n====\r\n\r\nProject for Unix Programming.\r\n\r\n## Authors\r\n\r\n* Landan Young Jackson <lmj0011@uah.edu>\r\n\r\n* Andrew Webb <adw0022@uah.edu>\r\n\r\n* Jacob <jak0013@uah.edu>\r\n\r\n* Julian Sy <jns0019@uah.edu>\r\n\r\n* Mike Ryan <mar0018@uah.edu>\r\n\r\n## Concepts\r\n\r\nThis take on the mysh project employs a number of different concepts to meet the project requirements:\r\n\r\n### No Regular Expressions\r\n\r\nInstead of using regular expressions to parse commands entered in our shell, commands are broken into words and pushed onto a queue where each word is resolved one by one. For instance, the following command:\r\n\r\n    ls ~ -l >> output.txt\r\n\r\nwould create a queue that looks like this:\r\n\r\n1. ls\r\n2. ~\r\n3. -l\r\n4. >>\r\n5. output.txt\r\n\r\nDuring parsing, we assume that the top of the queue is the command name. Then, as we resolve the queue we determine whether the string being parsed is a flag, argument, or operator by looking at the first two characters.\r\n\r\n### Specific classes for each command\r\n\r\nTo keep code clean, maintainable, and most importantly testable, we have broken each command out into their own classes. Each of these inherit from a parent Command class.\r\n\r\n### Use inversion of control to resolve command classes\r\n\r\nIn order to make our shell extensible, we have implemented a very basic IOC container. Basically, when we implement a new Command class, we register it with the command IOC. When a command is parsed in our shell, we first try to resolve a command class from this IOC. If we haven't implemented the class yet, the command is instead executed externally.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}